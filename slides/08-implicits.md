# Implicits


## Why implicit?
### How do you extend third party libraries to meet your specific coding requirements?
* Ruby has modules, Smalltalk let packages add to each other's classes. It's powerful but dangerous since the changes are global
* C# 3.0 has static extension methods => more local and more restrictive, and safer
* Scala: using implicit conversions and parameters to avoid tedious and boilerplate details.


## Implicit Rules
Need `implicit` keyword:
```scala
implicit def convert(x: Double) = x.toString
```

An inserted implicit conversion must be in scope as a single identifier
```scala
scala> object MyConversions {
     |   implicit def convert1(x: String): Int = x.size
     |   implicit def convert2(x: Float): Int = x.toInt
     | }
warning: there were two feature warnings; re-run with -feature for details
defined object MyConversions

scala> val x: Int = "123"
<console>:13: error: type mismatch;
 found   : String("123")
 required: Int
       val x: Int = "123"
                    ^

scala> import MyConversions.convert1 // has convert1 in scope
import MyConversions.convert1

scala> val x: Int = "123"
x: Int = 3

scala> import MyConversions._ // has both in scope, but dangerous
import MyConversions._
```


, or be associated with the source or target type of the conversion
```scala
class Euro { ??? }
class Dollar {
  // toEuro() is in scope
}
object Dollar {
  implicit def toEuro(x: Dollar): Euro = ???
}

```

One at a time
```
compiler will never do convert1(convert2(x))
```
Explicit first


## Implicit Conversion
Compiler does the trick: When compiler sees a type error, it looks for implicit conversions (therefore, increase the compilation time)
```scala
     | val x: Int = 1.9
<console>:19: error: type mismatch;
 found   : Double(1.9)
 required: Int
       val x: Int = 1.9
                    ^
```
Converting an expected type:
```scala
     | implicit def convert1(x: Double) = x.toInt
warning: there was one feature warning; re-run with -feature for details
convert1: (x: Double)Int

scala> val x: Int = 1.9
x: Int = 1
```
Converting the receiver:
```scala
scala> (1 to 4).foreach(print)
1234
scala> Map("a" -> 1, "b" -> 2)
res2: scala.collection.immutable.Map[String,Int] = Map(a -> 1, b -> 2)
```


## Implicit Classes
```scala
scala> case class Rectangle(width: Int, height: Int)
defined class Rectangle

scala> implicit class RectangleMaker(width: Int) {
     |   def x(height: Int) = Rectangle(width, height)
     | }
defined class RectangleMaker

scala> val myRectangle = 3 x 4
myRectangle: Rectangle = Rectangle(3,4)
```
```
// Automatically generated by compiler
implicit def RectangleMaker(width: Int) = new RectangleMaker(width)
```


## Implicit Parameters
```scala
scala> def maxList[T](elements: List[T])(implicit ordering: Ordering[T]): T =
     |   elements match {
     |     case List() =>
     |       throw new IllegalArgumentException("empty list!")
     |     case List(x) => x
     |     case x :: rest =>
     |       val maxRest = maxList(rest)(ordering)    // (ordering) is implicit
     |       if (ordering.gt(x, maxRest)) x           // ordering is explicit
     |       else maxRest
     | }
maxList: [T](elements: List[T])(implicit ordering: Ordering[T])T
```


implicitly[]
```scala
scala> def maxList[T](elements: List[T])(implicit foo: Ordering[T]): T =  // name doesn't matter
     |   elements match {
     |     case List() =>
     |       throw new IllegalArgumentException("empty list!")
     |     case List(x) => x
     |     case x :: rest =>
     |       val maxRest = maxList(rest)                        // (ordering) is gone
     |       if (implicitly[Ordering[T]].gt(x, maxRest)) x      // use implicitly[]  
     |       else maxRest
     | }
maxList: [T](elements: List[T])(implicit foo: Ordering[T])T
```


context bound: less code is better
```scala
scala> def maxList[T : Ordering](elements: List[T]): T =
     |   elements match {
     |     case List() =>
     |       throw new IllegalArgumentException("empty list!")
     |     case List(x) => x
     |     case x :: rest =>
     |       val maxRest = maxList(rest)
     |       if (implicitly[Ordering[T]].gt(x, maxRest)) x
     |       else maxRest
     | }
maxList: [T](elements: List[T])(implicit evidence$1: Ordering[T])T
```



## Implicit Search
## TypeClasses
## Contexts
